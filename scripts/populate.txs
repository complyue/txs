
conc = 6;
total'txc = 360000;

-- put the db object into the global scope, before `concur` copies it
-- for each thread to start running concurrently
db = {};

print $ "Populating using concurrency: " ++ conc;
resetMetrics();
-- | fork more threads each with a copy of the global scope at the time of the
-- fork, and wait all threads terminate before return.
--
-- concur :: NumThreads -> Any -> NilValue
concur conc $

  -- | repeat the evaluation of its argument expression, for the specified
  -- number of times.
  --
  -- repeat :: CountNumber -> Any -> NilValue
  repeat { total'txc / conc } {

    -- assign one global unique identifier
    --
    -- guid :: Any -> IntValue
    oid = guid ();

    (
      obj = {};
      obj.oid = oid;
      -- todo more obj attrs to fill
      db@oid = obj;
    );

    -- | report the completion of one transaction, it's up to the
    -- implementation of the host procedure that, how statistics, like TPS
    -- over time, are gathered and visualized.
    --
    -- metricOneTx :: Any -> NilValue
    metricOneTx ();
  
  }
