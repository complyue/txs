
-- put the db object into the global scope, before `concur` copies it
-- for each thread to start running concurrently
db = {};
db.cntr = 1;

-- | fork more threads each with a copy of the global scope at the time of the
-- fork, and wait all threads terminate before return.
--
-- concur :: NumThreads -> Any -> NilValue
concur 3 $

  -- | repeat the evaluation of its argument expression, for the specified
  -- number of times.
  --
  -- repeat :: CountNumber -> Any -> NilValue
  repeat 600000 {
    ( -- this tx makes the program scale poorly at concurrency, but a simple
      -- correct implementation. here we would diagnostic other issues, like
      -- excessive allocation made during interpreted execution of the script,
      -- which prevents the up scaling at heap size, by excessive GC time,
      -- even at light concurrency.
      ident = db.cntr;
      db.cntr = ident+1;
    );
    obj = {};
    obj.eid = ident;
    -- todo more obj attrs to fill
    db@ident = obj;

    -- | report the completion of one transaction, it's up to the
    -- implementation of the host procedure that, how statistics, like TPS
    -- over time, are gathered and visualized.
    --
    -- metricOneTx :: Any -> NilValue
    metricOneTx ();
  }
