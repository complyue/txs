
conc = 6;
total'txc = 36000;

-- put the db object into the global scope, before `concur` copies it
-- for each thread to start running concurrently
db = {};

print $ "Populating using concurrency: " ++ conc;
resetMetrics();
-- | fork more threads each with a copy of the global scope at the time of the
-- fork, and wait all threads terminate before return.
--
-- concur :: NumThreads -> Any -> NilValue
concur conc $

  -- | repeat the evaluation of its argument expression, for the specified
  -- number of times.
  --
  -- repeat :: CountNumber -> Any -> NilValue
  repeat { total'txc / conc } {
    repeat 30 { -- 30 objets per (metric-wise) TX

      -- assign one global unique identifier
      -- this can not be in a TX block
      --
      -- guid :: Any -> IntValue
      oid = guid ();

      ( -- one STM TX block per single object insertion
        obj = {};
        obj.oid = oid;
        -- todo more obj attrs to fill
        db@oid = obj;
      );

    };

    -- | report the completion of one transaction, it's up to the
    -- implementation of the host procedure that, how statistics, like TPS
    -- over time, are gathered and visualized.
    --
    -- metricOneTx :: Any -> NilValue
    metricOneTx ();

    -- | Suspends the current thread for a given number of microseconds
    --
    -- sleep :: IntValue -> NilValue
    sleep 1000;
  
  };
